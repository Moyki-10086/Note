## 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？

### 分析一：SPA的含义及作用
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

### 分析二：用户体验（快 ---> 局部更新 ---> 服务器压力小）；代码优化（前后端分离 ---> 开发效率高）
**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；通过使用异步加载数据和资源，SPA可以在初始加载后，只请求需要的数据，避免了不必要的网络传输，减少了带宽消耗和服务器压力。
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；SPA采用前后端分离的架构，前端负责页面的渲染和交互逻辑，后端只需要提供数据接口，使得前后端开发可以并行进行，提高了开发效率。
- 跨平台跨设备：SPA可以轻松适配不同的浏览器和设备，同时也方便与原生移动应用进行集成。

### 分析三：用户体验（单页面 ---> 首屏慢/SEO）；代码优化（单页面 ---> 路由/占内存）
**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
- 内存占用较大：SPA在使用过程中会将所有的页面内容保留在内存中，这可能导致较高的内存占用，特别是在处理大量数据或长时间运行的应用程序时。

## 2、v-show 与 v-if 有什么区别？

### 分析一：v-if 底层实现原理
**v-if** 是**真正**的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

### 分析一：v-show 底层实现原理
**v-show** 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。

### 分析三：适用场景
所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

## 3、Class 与 Style 如何动态绑定？

### 分析一：class 实现动态绑定方式 ：对象、数组
Class 可以通过对象语法和数组语法进行动态绑定：

- 对象语法：

```
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>

data: {
  isActive: true,
  hasError: false
}
复制代码
```

- 数组语法：

```
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
复制代码
```

### 分析二：style 实现动态绑定方式 ：对象、数组
Style 也可以通过对象语法和数组语法进行动态绑定：

- 对象语法：

```
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

data: {
  activeColor: 'red',
  fontSize: 30
}
复制代码
```

- 数组语法：

```
<div v-bind:style="[styleColor, styleSize]"></div>

data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}
复制代码
```

## 4、怎样理解 Vue 的单向数据流？

### 分析一：单项数据流 ---> 父子组件通信 ---> prop属性 ---> prop作用
所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
### 分析二： 子传父、父传子 之间的通信
这意味着数据在应用程序中只能从父组件向子组件传递，子组件不能直接修改父组件的数据。这种单向数据流的模式有助于维护应用程序的可预测性和可维护性。

额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

### 分析三：单项数据流的作用
这种单向数据流的模式使得应用程序的数据流动清晰可见，易于理解和调试。它也有助于组件的解耦和复用，因为子组件不依赖于父组件的具体实现细节，只关注所需的属性和响应事件即可。

### 分析四：总结 ，prop常见使用情况（直接使用原值、在原值的基础上修改）
总结起来，Vue的单向数据流模式通过属性(props)的传递和自定义事件的触发来实现数据在父子组件之间的流动，确保数据的可预测性和可维护性。


有两种常见的试图改变一个 prop 的情形 :

- **这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。** 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：

```js
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
复制代码
```

- **这个 prop 以一种原始的值传入且需要进行转换。** 在这种情况下，最好使用这个 prop 的值来定义一个计算属性

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
复制代码
```




## 5、computed 和 watch 的区别和运用的场景？

### 分析一：computed的含义
**computed：** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；实现 computed 缓存时，会将计算属性的计算结果存储在内部缓存中，可以直接读取缓存而不需要重新计算
- 在计算属性的 getter 函数中访问的所有响应式依赖都会被收集起来，并在依赖发生变化时触发更新。当没有任何组件再依赖该计算属性时，其缓存也会被自动清除。这种方式既能保证计算属性的正确性，又能避免内存泄漏的问题。
### 分析二：watch的含义
**watch：** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

### 分析三：适用场景
**运用场景：**

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。


## 6、JS创建线程：
### 使用web workers
<script>
  // 创建一个 Web Worker 实例
  var worker = new Worker('worker.js')
  worker.onmessage = function(event){
    // 内容 
  }
  // 在主线程中终止线程
  worker.terminate();
</script>
- var worker = new Worker('worker.js')：
这一行创建了一个名为 worker 的 Web Worker 实例，并指定了要在后台运行的脚本文件为 'worker.js'。'worker.js' 是一个独立的 JavaScript 文件，它将在 Web Worker 内部执行。Web Worker 可以独立于主线程运行，因此它不会影响主线程的性能。

- worker.onmessage：
这是一个事件处理程序，它会在 Web Worker 发送消息给主线程时触发。当 Web Worker 执行完一些任务后，它可以通过 postMessage 方法将结果发送回主线程，然后主线程可以通过这个事件处理程序来处理收到的消息。

- function(event)：
这是一个接受事件对象 event 的回调函数。在这个函数内，你可以处理来自 Web Worker 的消息。event.data 属性包含了 Web Worker 发送的数据。