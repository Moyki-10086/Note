## 路由守卫（Route Guards）
是在Vue Router中用于对路由进行监控和控制的功能。通过使用路由守卫，我们可以在路由跳转前、跳转后或是在路由变化时执行一些特定的操作。

### Vue Router提供了三种类型的路由守卫：
- **每个函数都有三个参数**
* to：即将跳转的路由对象。
* from：当前导航正要离开的路由对象。
* next：必须调用该函数来resolve这个钩子。
- **afterEach只有两个参数，完成进入页面，不需要使用next**
* to：即将跳转的路由对象。
* from：当前导航正要离开的路由对象。
- **next函数用于决定导航的行为**
* 调用next()：表示继续进行导航。
* 调用next(false)：中断导航，不进行跳转。
* 调用next('/path')：导航到特定的路径。
* 调用next(error)：导航到一个错误路由。 
* 不调用next()：不进行跳转。 

#### 全局前置守卫（Global Before Guards）：写在 router文件夹里

- beforeEach：在每个路由跳转之前都会被调用（进入页面之前，包括刷新页面），可以用来做全局的权限验证、登录状态判断或加载动画等公共操作。
- beforeResolve：在导航被确认之前，同时在所有组件内的守卫和异步路由组件被解析之后调用。
- afterEach：完成导航,进入路径之后，不需要next参数。可用于结束加载动画（进度条）等收尾工作
  - 例子：
 router.afterEach((to, from) => {
  console.log('-----afterEach------')
 })
  

#### 单个路由独享的守卫（Per-Route Guard）：写在routes数组里

- beforeEnter：只在当前路由配置生效的守卫，用于对特定路由进行额外的验证或处理。
  - 例子：
  {
    path: '/about',
    name: 'About',
    component: () => import('../views/About.vue'),
    beforeEnter(to, from, next) {
      console.log('----about route enter-----')
      next()
    }
  

#### 组件内的守卫（In-Component Guard）：

- beforeRouteEnter：在路由进入组件之前调用，允许我们在组件渲染之前访问组件实例。**注意**：在此守卫中不能获取组件实例this,当前守卫执行前，组件实例没被创建
- beforeRouteUpdate：在当前路由更新，但是该组件被复用时调用，允许我们在组件复用之前访问组件实例。
- beforeRouteLeave：在离开当前路由时调用，允许我们在离开前对组件进行确认、取消（禁止）离开、进入指定页面等操作。

### 使用路由守卫可以实现很多常见的功能，如：

- 路由权限控制：在全局前置守卫中验证用户的登录状态或角色权限，如果未登录或权限不足，可以跳转到登录页面或提示无权限。
- 路由加载状态管理：使用beforeEnter守卫来控制某些路由的异步加载，可以根据需要进行动态加载，提高应用性能。
- 数据预取和加载：在beforeRouteEnter守卫中获取组件所需的数据，并传递给组件进行渲染，避免在组件内部发起数据请求。


### 完整的导航解析流程:（全局前置守卫 -> 单个路由独享的守卫 -> 组件内的守卫）
- 1.导航被触发。
- 2.在失活的组件里调用beforeRouteLeave守卫。
- - a.如果页面中有重要的信息需要用户保存后才能进行跳转，可以在这里 拦截给出提示信息。
- - b.当开启组件缓存的时候是不会触发destroy等销毁的生命周期钩子函数，也就无法在组件销毁的时候做一些清理工作（比如清除定时器）﹔这种情况如果想要让页面离开的时候做清理则可以借助这个导航守卫。
- 3.调用全局的beforeEach守卫。
- - a.开始加载动画
- - b.校验页面访问权限
- 4.在重用的组件里调用beforeRouteUpdate守卫(2.2+)。
- - a.路由参数改变时触发这个钩子，例如从/foo/1和 /foo/2之间跳转的时候需要重新请求数据，这种类型的跳转不会触发created生命周期函数，可以通过该钩子函数或者监听$route来实现。
- 5.在路由配置里调用beforeEnter。
- 6.解析异步路由组件。
- 7.在被激活的组件里调用beforeRouteEnter。
- 8.调用全局的beforeResolve守卫(2.5+)。
- 9.导航被确认。
- 10.调用全局的afterEach钩子。
- - a.结束加载动画
- 11.触发dom更新
- 12.调用beforeRouterEnter守卫传给next的回调函数，创建好的组件实例会作为回调函数的参数传入

  
### 补充
在更新路由路径时，如果相同组件不同路径（组件重复调用的情况）
- 以下的Vue生命周期钩子函数会被调用：

  - beforeRouteUpdate(to, from, next)：在当前路由更新但组件被复用时调用。这个钩子函数会在组件复用之前调用，允许你访问组件实例并对其进行适当的操作。你可以通过to和from参数来获取当前和前一个路由对象。

  - 也可以通过 watch 实现
watch: {
   $route () {
     console.log('about route update watch');
   }
 }

- 以下的Vue生命周期钩子函数不会被调用：

 - beforeCreate：在实例初始化之后，在创建之前，此时尚未创建组件实例。
 - created：在实例创建完成后调用，此时组件已经创建，但尚未挂载到DOM上。
 - beforeMount：在组件挂载到DOM之前调用，此时组件实例已经创建完成，并且相关的DOM还未生成。
 - mounted：在组件挂载到DOM之后调用，此时组件已经被插入到DOM中。

#### 为什么这些生命周期钩子函数不会被调用呢？
  
  当路由路径更新但组件保持相同时，Vue Router会复用相同组件的实例，而不是重新创建一个新的实例。因此，Vue只会调用适用于复用组件的生命周期钩子函数（如beforeRouteUpdate），以允许你在组件复用时执行必要的操作，而不是再次触发组件的创建过程。这样可以提高性能并确保组件的状态得以保留。
则不会执行vue生命周期中的 create 钩子函数，
