####
在Node中每一个js文件都是一个单独的模块,通过 CommonJS，每个 JS 文件独立地存储它模块的内容（就像一个被括起来的闭包一样）
- 语法
  1. 模块必须要使用require()导入
  2. 模块必须要使用module.exports导出
    这两个语法都是nodejs环境自带的全局语法
- 
  导出模块语法一般放在js文件最底部，且只需要执行一次即可
- 
  一般不需要把模块化中所有的变量全部都导出，只需要导出需要用的变量即可
- 模块缓存机制
  1. 当一个模块第一次加载时，nodejs会执行里面的代码，并且导出模块
  2. nodejs会将导出的模块放入缓存中
  3. 当重复导入一个模块的时候，nodejs会先从缓存中读取模块。如果缓存中有，就会从缓存读取。缓存没有就重复步骤1

#### nodejs三种模块及require()加载原理
##### nodejs有三种模块
1. 有一种: 核心模块、内置模块
nodejs作者写的，这些模块js文件会随着安装nodejs的时候一起安装。因此我们可以直接使用，而无需下载。
例如：fs、path、http都是核心模块

2. 第二种：第三方模块
npm官网上面的模块，这些都是大佬写的模块。需要下载后使用
例如：express、cors、bod-parser

3. 第三种：自定义模块
我们自己写的文件

##### require('文件路径')加载原理
1. 自定义模块：必须要写文件路径，require()会得到这个模块里面的module.exports对象
2. 第三方模块：写模块名。nodejs会自动从你的node_module文件夹里面去找这个模块的名字，然后执行模块里面的index.js代码，得到里面的module.exports。如果当前目录没有module.exports就会从上级目录找，以此类推。一直找到你的磁盘根目录。还找不到就会提示报错模块不存在(类似变量作用域的就近原则)
3. 核心模块：写模块名。nodejs会自动从你的node安装包路径里面去找。

###### 案例2
通过指定导出的对象名称，CommonJS 模块系统可以识别在其他文件引入这个模块时应该如何解释。
然后在某个人想要调用 myMoudle 的时候，只需要 require 一下
1.  这种实现比起模块模式有两点好处：
  - 避免全局命名空间污染
  - 明确代码之间的依赖关系


